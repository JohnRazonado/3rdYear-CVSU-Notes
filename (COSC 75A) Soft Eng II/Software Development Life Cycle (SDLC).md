#inProgress 
## Life Cycle Model
- Also called a *process model*
- Descriptive and diagrammatic representation of the software life cycle.
- Represents all activities required to make software product transit through its life cycle phases.
- Captures order in which these activities are to be undertaken.

## Need for Software Life Cycle Model
- Dev team must identify life cycle model for particular project and adhere to it.
- Without it, development of software product wouldn't be [[Software Engineering#Software Engineering|systematic and disciplined manner]].
- There must be clear understanding among team members about when and what to do. Otherwise, chaos would ensue leading to project failure.
- Phase can start only if its phase-entry criteria been satisfied.

## Different Software Life Cycle Model
Each has some advantages and disadvantages.

> This part is a combination of each summary of the model and [[Software Development Life Cycle (SDLC)#Comparison of Different Life Cycle Models|comparison of different life cycle models]]

- **[[Classical Waterfall Model]]**
	- considered as *basic model* and all other life cycle models as embellishments(add-on) of this model.
	- Cannot be used in practical development projects, since it supports no mechanism to handle errors committed during any of the phases.
- **[[Iterative Waterfall Model]]**
	- Overcomes the problem of [[classical waterfall model]]. Probably the *most widely used software development model* evolved so far. 
	- This model is simple to understand and use.
	- However this model is suitable only for well-understood problems; it is not suitable for very large projects and for projects that are subject to many risks.
- **[[Prototyping Model]]**
	- Suitable for projects which either the user requirements or underlying technical aspects are not well understood.
	- Especially popular for development of the user-interface part of the projects.
- **[[Evolutionary Model]]**
	-  Suitable for large problems which can be decomposed into a set of modules for incremental development and delivery. 
	- Widely used for *object- oriented development projects*. 
	- Can only be used if the incremental delivery of the system is acceptable to customer
- **[[Spiral Model]]**
	- Also called *meta model* since it encompasses all other life cycle models.
	- Risk handling is inherently built into this model. 
	- Suitable for development of technically challenging software products that are prone to several kinds of risks. 
	- This model is much more complex than the other models – this is probably a factor deterring its use in ordinary projects.

## Comparison of Different Life Cycle Models
- Different software life cycle models can be compared from the viewpoint of the customer. 
- Initially, customer confidence in the development team is usually high irrespective of the development model followed. 
- During lengthy development process, customer confidence normally drops off, as no working product is immediately visible.
	- Developers answer customer  using technical slang, and delays are announced.
	- This gives rise to customer resentment.
- On the other hand, an evolutionary approach lets the customer experiment with a working product much earlier than the monolithic approaches. 
	- Another important advantage of the incremental model is that it reduces the customer’s trauma of getting used to an entirely new system. The gradual introduction of the product via incremental phases provides time to the customer to adjust to the new product. 
	- Also, from the customer’s financial viewpoint, incremental development does not require a large upfront capital outlay. 
	- The customer can order the incremental versions as and when he can afford them.
